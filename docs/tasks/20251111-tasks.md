# 実装タスク: WebSocket チャットアプリのテスト実装とリファクタリング

作成日: 2025-11-11

## 目的

`src/server` と `src/client` に包括的なテストを追加し、テスタブルなアーキテクチャにリファクタリングする。
twada の TDD ワークフロー（https://t-wada.hatenablog.jp/entry/canon-tdd-by-kent-beck）に従い、ドメインロジックと技術的関心事を分離する。

## テスト観点

### 1. ドメインロジック（高優先度）

純粋関数として抽出し、単体テストで検証する。

#### Server 側

- **参加者リスト生成**: `connected_clients` から `ParticipantInfo` リストを構築
- **重複クライアント検出**: 既存の `client_id` かどうかの判定
- **ブロードキャスト対象選定**: 送信者を除く全クライアントの抽出
- **タイムスタンプ生成**: JST ミリ秒の決定論的生成

#### Client 側

- **メッセージパース**: サーバーからの JSON メッセージを適切な型にデシリアライズ
- **再接続判定**: エラー種別から再接続すべきかの判定ロジック
- **タイムスタンプフォーマット**: ミリ秒を人間可読な JST 文字列に変換
- **メッセージフォーマット**: 各メッセージタイプを表示用文字列に整形

### 2. 統合テスト（高優先度）

実際のサーバー・クライアント間の通信を検証する。

- **クライアント登録フロー**: WebSocket 接続 → room-connected メッセージ受信
- **重複 client_id 拒否**: 同じ client_id での接続時に HTTP 409 が返される
- **メッセージブロードキャスト**: 1 クライアントの送信が他クライアントに配信される
- **参加者通知**: 新規接続/切断時に participant-joined/left が配信される
- **接続/切断フロー**: 正常な接続確立とクリーンアップ

### 3. UI/I-O（低優先度）

現時点では手動テストで十分。将来的に必要に応じて自動化を検討。

- プロンプト表示とカーソル制御
- rustyline との統合
- 標準入出力のフォーマット

## テストの設計

### Phase 1: ドメインロジックの抽出と単体テスト

**目的**: ビジネスロジックを純粋関数として抽出し、I/O から分離する。

#### 実装内容

1. **`src/server/domain.rs` の作成**

   ```rust
   // 参加者リスト生成（純粋関数）
   pub fn build_participant_list(
       connected_clients: &HashMap<String, ClientInfo>
   ) -> Vec<ParticipantInfo>

   // 重複チェック（純粋関数）
   pub fn is_duplicate_client(
       connected_clients: &HashMap<String, ClientInfo>,
       client_id: &str
   ) -> bool

   // ブロードキャスト対象取得（純粋関数）
   pub fn get_broadcast_targets<'a>(
       connected_clients: &'a HashMap<String, ClientInfo>,
       exclude_client_id: &str
   ) -> Vec<(&'a String, &'a ClientInfo)>
   ```

2. **`src/client/domain.rs` の作成**

   ```rust
   // メッセージパース（純粋関数）
   pub fn parse_server_message(
       json_str: &str
   ) -> Result<MessageType, ParseError>

   // 再接続判定（純粋関数）
   pub fn should_reconnect(
       error: &ClientError,
       attempt: u32,
       max_attempts: u32
   ) -> bool
   ```

3. **テストの追加**
   - 各関数に対して指定フォーマットで単体テストを記述
   - エッジケース（空リスト、境界値など）を網羅

#### テストフォーマット

```rust
#[test]
fn test_build_participant_list_with_multiple_clients() {
    // テスト項目: 複数クライアント接続時に正しい参加者リストが生成される
    // given (前提条件):
    let mut clients = HashMap::new();
    clients.insert("alice".to_string(), ClientInfo { ... });
    clients.insert("bob".to_string(), ClientInfo { ... });

    // when (操作):
    let result = build_participant_list(&clients);

    // then (期待する結果):
    assert_eq!(result.len(), 2);
    assert!(result.iter().any(|p| p.client_id == "alice"));
    assert!(result.iter().any(|p| p.client_id == "bob"));
}
```

### Phase 2: Clock 抽象化の実装

**目的**: 時刻依存のコードを決定論的にテスト可能にする。

#### 実装内容

1. **`src/time.rs` の拡張**

   ```rust
   // Clock trait の定義
   pub trait Clock: Send + Sync {
       fn now_jst_millis(&self) -> i64;
   }

   // 本番環境用
   pub struct SystemClock;
   impl Clock for SystemClock {
       fn now_jst_millis(&self) -> i64 {
           // 現在時刻を返す
       }
   }

   // テスト用
   pub struct FixedClock {
       fixed_time: i64,
   }
   impl Clock for FixedClock {
       fn now_jst_millis(&self) -> i64 {
           self.fixed_time
       }
   }
   ```

2. **テストの追加**
   - `FixedClock` を使った決定論的なタイムスタンプテスト
   - フォーマット関数のテスト

### Phase 3: Message Handler の分離

**目的**: WebSocket I/O と状態操作ロジックを分離する。

#### 実装内容

1. **`src/server/message_handler.rs` の作成**

   ```rust
   pub struct MessageHandler {
       state: Arc<AppState>,
       clock: Arc<dyn Clock>,
   }

   impl MessageHandler {
       // room-connected メッセージ生成
       pub async fn handle_room_connected(&self, client_id: &str) -> String

       // chat メッセージのブロードキャスト
       pub async fn handle_chat_message(&self, from: &str, content: &str) -> Result<(), Error>

       // 参加者追加通知
       pub async fn handle_participant_joined(&self, client_id: &str) -> Result<(), Error>
   }
   ```

2. **`src/server/handler.rs` のリファクタリング**
   - 巨大な `handle_socket` 関数を分割
   - `MessageHandler` を使用して状態操作を委譲

3. **テストの追加**
   - `MessageHandler` の各メソッドをモック状態でテスト
   - ブロードキャストロジックの検証

### Phase 4: UI Formatter の分離

**目的**: 表示ロジックを I/O から分離し、文字列フォーマットのテストを可能にする。

#### 実装内容

1. **`src/client/formatter.rs` の作成**

   ```rust
   pub struct MessageFormatter;

   impl MessageFormatter {
       // チャットメッセージのフォーマット
       pub fn format_chat_message(from: &str, content: &str, sent_at: i64) -> String

       // 参加者参加通知のフォーマット
       pub fn format_participant_joined(client_id: &str, connected_at: i64) -> String

       // 参加者退出通知のフォーマット
       pub fn format_participant_left(client_id: &str) -> String

       // room-connected メッセージのフォーマット
       pub fn format_room_connected(participants: &[ParticipantInfo]) -> String
   }
   ```

2. **`src/client/session.rs` のリファクタリング**
   - 巨大な関数を分割
   - `MessageFormatter` を使用して表示ロジックを委譲

3. **テストの追加**
   - 各フォーマット関数の出力を検証
   - タイムスタンプ表示の確認

### Phase 5: 統合テストの追加

**目的**: 実際のサーバー・クライアント間の通信を検証する。

#### 実装内容

1. **`tests/integration_test.rs` の作成**

   ```rust
   #[tokio::test]
   async fn test_duplicate_client_id_rejection() {
       // テスト項目: 重複する client_id での接続が HTTP 409 で拒否される
       // given (前提条件):
       // サーバー起動、alice で接続

       // when (操作):
       // 同じ client_id "alice" で再接続を試みる

       // then (期待する結果):
       // HTTP 409 Conflict が返される
   }

   #[tokio::test]
   async fn test_message_broadcast() {
       // テスト項目: メッセージが他のクライアントにブロードキャストされる
       // given (前提条件):
       // サーバー起動、alice と bob が接続

       // when (操作):
       // alice がメッセージ送信

       // then (期待する結果):
       // bob がメッセージを受信、alice は受信しない
   }
   ```

2. **テストヘルパーの作成**
   - テスト用サーバー起動関数
   - テスト用クライアント接続関数
   - メッセージ送受信のアサーション関数

## 実装タスク

### 準備

- [x] タスクドキュメント作成
- [ ] `AGENTS.md` にタスクドキュメント管理ルールを追記
- [ ] `Cargo.toml` に `mockall = "0.13"` を dev-dependencies に追加

### Phase 1: ドメインロジックの抽出

- [ ] `src/server/domain.rs` を作成
  - [ ] `build_participant_list` 関数と単体テスト
  - [ ] `is_duplicate_client` 関数と単体テスト
  - [ ] `get_broadcast_targets` 関数と単体テスト
- [ ] `src/client/domain.rs` を作成
  - [ ] `parse_server_message` 関数と単体テスト
  - [ ] `should_reconnect` 関数と単体テスト
- [ ] `src/server/mod.rs` に `domain` モジュールを追加
- [ ] `src/client/mod.rs` に `domain` モジュールを追加

### Phase 2: Clock 抽象化

- [ ] `src/time.rs` を拡張
  - [ ] `Clock` trait を定義
  - [ ] `SystemClock` を実装
  - [ ] `FixedClock` を実装（テスト用）
  - [ ] タイムスタンプフォーマット関数のテスト追加
- [ ] `src/server/handler.rs` で `Clock` を使用
- [ ] `src/client/session.rs` で `Clock` を使用

### Phase 3: Message Handler の分離

- [ ] `src/server/message_handler.rs` を作成
  - [ ] `MessageHandler` 構造体と実装
  - [ ] `handle_room_connected` メソッドと単体テスト
  - [ ] `handle_chat_message` メソッドと単体テスト
  - [ ] `handle_participant_joined` メソッドと単体テスト
  - [ ] `handle_participant_left` メソッドと単体テスト
- [ ] `src/server/handler.rs` をリファクタリング
  - [ ] `MessageHandler` を使用するように修正
  - [ ] 巨大な関数を分割
- [ ] `src/server/mod.rs` に `message_handler` モジュールを追加

### Phase 4: UI Formatter の分離

- [ ] `src/client/formatter.rs` を作成
  - [ ] `MessageFormatter` 構造体と実装
  - [ ] `format_chat_message` メソッドと単体テスト
  - [ ] `format_participant_joined` メソッドと単体テスト
  - [ ] `format_participant_left` メソッドと単体テスト
  - [ ] `format_room_connected` メソッドと単体テスト
- [ ] `src/client/session.rs` をリファクタリング
  - [ ] `MessageFormatter` を使用するように修正
  - [ ] 表示ロジックを分離
- [ ] `src/client/mod.rs` に `formatter` モジュールを追加

### Phase 5: 統合テスト

- [ ] `tests/integration_test.rs` を作成
  - [ ] テストヘルパー関数の実装
  - [ ] `test_duplicate_client_id_rejection` テスト
  - [ ] `test_message_broadcast` テスト
  - [ ] `test_participant_joined_notification` テスト
  - [ ] `test_participant_left_notification` テスト
  - [ ] `test_connection_and_disconnection_flow` テスト

### 最終確認

- [ ] `cargo fmt` でコードを整形
- [ ] `cargo clippy --all-targets --all-features` で lint
- [ ] `cargo test` で全テストが通ることを確認
- [ ] `AGENTS.md` のテスト指針セクションを更新

## 進捗状況

- **開始日**: 2025-11-11
- **現在のフェーズ**: Phase 1 準備中
- **完了したタスク**: 1/50+
- **次のアクション**: フォーマットテンプレート作成、`AGENTS.md` 更新と `Cargo.toml` への依存追加

## 備考

- テストフォーマットは `// テスト項目:` の後に半角スペースを必ず入れる
- 各 given/when/then セクションの間は空行を 1 行入れる
- ドメインロジックは可能な限り純粋関数として抽出する
- テストは TDD のサイクル（Red → Green → Refactor）に従って実装する
